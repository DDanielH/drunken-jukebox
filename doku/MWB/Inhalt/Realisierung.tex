\section{Realisierung}

In diesem Kapitel wird die konkrete Umsetzung der Anforderungen in GWT beschreiben.
Zuerst wird die Architektur der Anwendung festgelegt. Anschließend werden konkrete
Implentierungsdetails erläutert, welche die Erstellung eigener Widgets in GWT und
mittels JSNI, das Styling in GSS sowie die Lokalisierung umfassen.

\subsection{Architektur}

Um den Anforderungen der zwei Anwendergruppen (Veranstalter und Gäste einer Party) gerecht
zu werden, entwickeln wir zwei GWT-Anwendungen. Die Admin-Oberfläche wird als Desktop-Webanwendung
entwickelt, während die Vote-App als mobile Webanwendung umgesetzt wird. Trotzdem werden
beide Anwendungen mit einer ähnlichen Softwarearchitektur implementiert.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/Architektur-Ueberblick}
\caption{Überblick über die Architektur der beiden Anwendungen}
\label{fig:Architektur-Ueberblick}
\end{figure}

Die Frontend-Webapplikationen kommunizieren über GWT-RPC mit einem Java-Server. Dieser dient als 
Proxy zum deployd\footnote{\url{http://deployd.com/}}-Server und enthält selbst keine Applikationslogik. Auf diese Weise umgehen wir das Problem der Same-Origin-Policy. Der deployed-Server
ist für die Persistenz der Daten und die Anwendungslogik verantwortlich und wird über eine
HTTP-Schnittstelle angesprochen.

\subsubsection{Frontend}
Innerhalb der GWT-Frontend-Anwendungen wird das MVP-Pattern zur Trennung von Steuerung und Anzeige
der Oberfläche implementiert. Der Zugriff auf das Model wird über GWT-RPC-Services ermöglicht, die Anfragen an den Java-Server im Backend durchführen (s. Abbildung \ref{fig:MVP-mit-Service}).

\begin{figure}[tbh]
\centering
\includegraphics[width=0.6\linewidth]{Bilder/MVP-mit-Service}
\caption{MVP-Pattern mit Service}
\label{fig:MVP-mit-Service}
\end{figure}

Im Folgenden werden die erstellten View-Presenter-Paare und deren Aufgaben kurz vorgestellt:
\begin{description}
	\item[PartyManagamentView und -Presenter:] Verwalten einer Party im Admin
	\item[SongManagementView und -Presenter:] Verwalten der Songsammlung im Admin
	\item[LanguageSelectionView und -Presenter:] Ändern der Anzeigesprache im Admin
	\item[VoteAppView und -Presenter:] Teilnahme an einer Party als Gast über die Vote-App
\end{description}

\subsubsection{Backend}
Das Backend besteht aus einem Java-Server, der als Proxy zur Umgehung der Same-Origin-Policy dient, und einem deployd-Server, der für die eigentliche Datenhaltung
und Anwendungslogik verantwortlich ist.

Der deployd-Server stellt Ressourcen über eine HTTP/REST-Schnittstelle bereit. Als
Datenformat wird JSON verwendet. Zur Einrichtung des deployd-Servers sind zwei Schritte
notwendig. Zunächst müssen die verwendeten Ressourcen definiert werden. Im zweiten
Schritt kann eigener Code\footnote{Der Code wird in JavaScript hinterlegt, da deployd auf node.js basiert.} hinterlegt werden, der beim Zugriff auf die Ressourcen
ausgeführt wird. Auf diese Weise konnten wir das notwendige Datenmodell und die
dazugehörige Anwendungslogik hinterlegen.

Die von uns definierten Ressourcen umfassen:
\begin{description}
	\item[/party] Daten über die aktuell laufende Party
	\item[/playlist] Die aktuelle Playlist (Songs und deren Votes)
	\item[/currentsong] Der Song, der gerade gespielt wird
	\item[/song] Songsammlung, aus der Songs für die Playlist gewählt werden
\end{description}

\subsection{Eigene Widgets}
Im Rahmen der Realisierung sind viele eigene Widgets entstanden. Um ein eigenes Widget zu implementieren leitet man von der Klasse Composite ab und ruft im Konstruktor die Methode initWidget auf. Neben kleineren Hilfskomponenten haben wir vor allem die Views als eigene Widgets realisiert.

Im Folgenden wird exemplarisch die Hilfskomponente InputBox und die SongListView vorgestellt.

\subsubsection{InputBox}
Die InputBox ist eine simple Hilfskomponente die eine TextBox und mit einem Label versieht:

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/InputBox}
\caption{InputBox für den Interpreten eines Songs}
\label{fig:InputBox}
\end{figure}

Abbildung \ref{fig:InputBoxClass} zeigt die Schnittstellenbeschreibung der InputBox. Im Konstruktor wird neben dem CSS-Style der Label-Text übergeben. Über die Methode setFocus kann der Fokus auf die TextBox gesetzt werden. Die Methoden setText, getText und clear sind zur Manipulation der Eingabe.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\linewidth]{Bilder/InputBoxClass}
\caption{Schnittstellenbeschreibung der InputBox}
\label{fig:InputBoxClass}
\end{figure}


\subsubsection{SongListView}
Die SongListView besteht aus einer TextBox für die Suche, einer ListBox und einem Button zur Erstellung eines neuen Songs:

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/SongListView}
\caption{Liste mit Suchmöglichkeit zur Verwaltung der Songs}
\label{fig:SongListView}
\end{figure}



\begin{figure}[H]
\centering
\includegraphics[width=0.4\linewidth]{Bilder/SongListViewClass}
\caption{Schnittstellenbeschreibung der SongListView}
\label{fig:SongListViewClass}
\end{figure}


\subsection{Styles in GSS}
Für das Styling der beiden GWT-Anwendungen verwenden wir GSS\footnote{\url{https://code.google.com/p/closure-stylesheets/}}. Da es unterschiedliche Anforderungen
an Deskop- und Mobilanwendungen gibt, werden zwei Stylesheet-Dateien verwendet.

Um die Styles im Java-Code verwenden zu können, müssen diese mit dem \texttt{AppResources}-Interface\footnote{Dieses Interface erbt von dem GWT-Interface \texttt{ClientBundle}} verbunden werden.
In diesem Projekt legen wir alle Ressourcen, zu denen auch Stylesheets zählen, in
einem separaten Package (\texttt{de.whs.drunkenjukebox.resources}) ab. Wie Abbildung
\ref{fig:GSS} zeigt, können so beide Anwendungen \texttt{AppResources} verwenden
und nur den jeweils benötigten Style nachladen.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.6\linewidth]{Bilder/GSS}
\caption{Verknüpfung der GSS-Dateien mit Java}
\label{fig:GSS}
\end{figure}


\subsection{Lokalisierung}
Beide Anwendungen sollen lokalisiert in Deutsch und Englisch angeboten werden.
Im Admin soll es möglich sein die Sprache über die Oberfläche zu ändern, während
in der Vote-App die Sprache automatisch ausgewählt werden soll.

\subsubsection{Properties-Dateien}

Zur Lokalisierung werden Properties-Dateien\footnote{http://www.gwtproject.org/doc/latest/DevGuideI18n.html} verwendet, welche über Interfaces
mit dem Java-Code verknüpft werden. Es gibt zwei Arten von übersetzbaren Texten:
\begin{description}
	\item[Statisch:] Text ohne Platzhalter
	\item[Dynamisch:] Text mit einem oder mehreren Platzhaltern
\end{description}
Diese Arten werden in GWT unterschiedlich behandelt. Für statische Text muss
von \texttt{Constants} und für dynamische Texte von \texttt{Messages} abgeleitet werden. In den Interfaces können Fallback-Texte hinterlegt werden, die angezeigt werden, wenn keine passende Übersetzung in den Properties-Dateien gefunden wurde. Als
Fallback-Sprache verwenden wir Englisch, so dass wir nur Properties-Dateien für
die deutsche Übersetzung anlegen müssen.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/Lokalisierung}
\caption{Übersetzung mittels Properties-Dateien}
\label{fig:Lokalisierung}
\end{figure}

Abbildung \ref{fig:Lokalisierung} zeigt, dass die Übersetzungsdateien in dem
\texttt{de.whs.drunkenjukebox.resources}-Package abgelegt sind. Um weitere
Übersetzungen hinzufügen müssen hier lediglich neue Properties-Dateien mit
dem entsprechenden Sprachkürzel angelegt und gefüllt werden.


\subsubsection{Wahl der Sprache}
In GWT kann die anzuzeigende Sprache über einen URL-Parameter bestimmt. Für die Admin-Oberfläche rufen wir die eigene URL
mit dem Parameter \texttt{locale} auf, um die vom Anwender
gewünscht Sprache anzuzeigen. Die zur Auswahl stehenden Sprachen werden dem Benutzer als Bilder angezeigt, auf denen Click-Handler den notwendigen Wechsel der URL herbeiführen.
\begin{lstlisting}[language=Java]
@Override
public void onClick(ClickEvent event) {
	String newUrl = Window.Location.getPath() + "?locale=de";
	Window.Location.assign(newUrl);
}
\end{lstlisting}
In der Vote-App soll die im Browser eingestellte Sprache verwendet werden. Dazu reicht ein Eintrag in dem GWT-Modul
der Anwendung:
\begin{lstlisting}[language=XML]
<set-configuration-property name="locale.useragent" value="Y"/>
\end{lstlisting}

\subsection{JSNI}
Die Eingabe des eigenen DI-Werts sollte mithilfe eines Sliders erfolgen. Leider enthält GWT kein natives Benutzerelement Slider, weswegen wir uns überlegt haben mithilfe von jQuery UI und JSNI einen HTML5 Slider zu implementieren. Dieser sollte auf seiten von GWT wie ein natives Widget benutzt werden können. Dazu war es nötig die JSNI Funktionen vor der direkten Benutzung, in ein Custom-Widget zu kapseln. 

JSNI ermöglicht es in einer GWT Applikation natives Javascript zu schreiben welcher bei der Kompilierung der Anwendung übernommen wird. 
Dadurch ist das mischen von Java und Javascript bei der Entwicklung möglich.

In unserem konkreten Problem haben wir eine neue Composite Klasse erstellt die Methoden zum setzen und lesen des Slider Wertes ermöglicht. Weiter ist es möglich ein SliderListener Interface zu setzen der beim "slide"-Event aufgerufen wird. Das Custom-Widget erstellt ein neues DIV Element, in welches mithilfe von jQuery UI ein Slider-Element eingebettet wird. Aus dem Javascript heraus wird die Slide-Methode der Java Seite aufgerufen. Zur Benutzung des Sliders müssend die entsprechenden jQuery und jQuery UI Bibliotheken im Head der HTML Datei eingebunden werden.
