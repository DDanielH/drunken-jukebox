\section{Realisierung}

In diesem Kapitel wird die konkrete Umsetzung der Anforderungen in GWT beschreiben.
Zuerst wird die Architektur der Anwendung festgelegt. Anschließend werden konkrete
Implentierungsdetails erläutert, welche die Erstellung eigener Widgets in GWT und
mittels JSNI, das Styling in GSS sowie die Lokalisierung umfassen.

\subsection{Architektur}

Um den Anforderungen der zwei Anwendergruppen (Veranstalter und Gäste einer Party) gerecht
zu werden, entwickeln wir zwei GWT-Anwendungen. Die Admin-Oberfläche wird als Desktop-Webanwendung
entwickelt, während die Vote-App als mobile Webanwendung umgesetzt wird. Trotzdem werden
beide Anwendungen mit einer ähnlichen Softwarearchitektur implementiert.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/Architektur-Ueberblick}
\caption{Überblick über die Architektur der beiden Anwendungen}
\label{fig:Architektur-Ueberblick}
\end{figure}

Die Frontend-Webapplikationen kommunizieren über GWT-RPC mit einem Java-Server. Dieser dient als 
Proxy zum deployd\footnote{\url{http://deployd.com/}}-Server und enthält selbst keine Applikationslogik. Auf diese Weise umgehen wir das Problem der Same-Origin-Policy. Der deployed-Server
ist für die Persistenz der Daten und die Anwendungslogik verantwortlich und wird über eine
HTTP-Schnittstelle angesprochen.

\subsubsection{Frontend}
Innerhalb der GWT-Frontend-Anwendungen wird das MVP-Pattern zur Trennung von Steuerung und Anzeige
der Oberfläche implementiert. Der Zugriff auf das Model wird über GWT-RPC-Services ermöglicht, die Anfragen an den Java-Server im Backend durchführen.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.6\linewidth]{Bilder/MVP-mit-Service}
\caption{MVP-Pattern mit Service}
\label{fig:MVP-mit-Service}
\end{figure}

Im Folgenden werden die erstellten View-Presenter-Paare und deren Aufgaben kurz vorgestellt:
\begin{description}
	\item[PartyManagamentView und -Presenter:] Verwalten einer Party im Admin
	\item[SongManagementView und -Presenter:] Verwalten der Songsammlung im Admin
	\item[LanguageSelectionView und -Presenter:] Ändern der Anzeigesprache im Admin
	\item[VoteAppView und -Presenter:] Teilnahme an einer Party als Gast über die Vote-App
\end{description}

\subsubsection{Backend}
Das Backend besteht aus einem Java-Server, der als Proxy zur Umgehung der Same-Origin-Policy dient, und einem deployd-Server, der für die eigentliche Datenhaltung
und Anwendungslogik verantwortlich ist.

Der deployd-Server stellt Ressourcen über eine HTTP/REST-Schnittstelle bereit. Als
Datenformat wird JSON verwendet. Zur Einrichtung des deployd-Servers sind zwei Schritte
notwendig. Zunächst müssen die verwendeten Ressourcen definiert werden. Im zweiten
Schritt kann eigener Code\footnote{Der Code wird in JavaScript hinterlegt, da deployd auf node.js basiert.} hinterlegt werden, der beim Zugriff auf die Ressourcen
ausgeführt wird. Auf diese Weise konnten wir das notwendige Datenmodell und die
dazugehörige Anwendungslogik hinterlegen.

Die von uns definierten Ressourcen umfassen:
\begin{description}
	\item[/party] Daten über die aktuell laufende Party
	\item[/playlist] Die aktuelle Playlist (Songs und deren Votes)
	\item[/currentsong] Der Song, der gerade gespielt wird
	\item[/song] Songsammlung, aus der Songs für die Playlist gewählt werden
\end{description}

\subsection{Eigene Widgets}
- Search Dinge
- PlaylistEntries

Beispiele

Chris

\subsection{Styles in GSS}
Für das Styling der beiden GWT-Anwendungen verwenden wir GSS. Da es unterschiedliche Anforderungen
an Deskop- und Mobilanwendungen gibt, werden zwei Stylesheet-Dateien verwendet.

- Verknüpfung: Client-Bundle und GSS-Dateien
- Gemeinsame Styles auslagern?

Fabian

\subsection{Lokalisierung}
Beide Anwendungen sollen lokalisiert in Deutsch und Englisch angeboten werden.
Im Admin soll es möglich sein die Sprache über die Oberfläche zu ändern, während
in der Vote-App die Sprache automatisch ausgewählt wird.

Dazu verwenden wir Ressourcen-Strings (TODO).

Fabian

\subsection{JSNI}
Die Eingabe des eigenen DI-Werts sollte mithilfe eines Sliders erfolgen. Leider enthält GWT kein natives Benutzerelement Slider, weswegen wir uns überlegt haben mithilfe von jQuery UI und JSNI einen HTML5 Slider zu implementieren. Dieser sollte auf seiten von GWT wie ein natives Widget benutzt werden können. Dazu war es nötig die JSNI Funktionen vor der direkten Benutzung, in ein Custom-Widget zu kapseln. 

JSNI ermöglicht es in einer GWT Applikation natives Javascript zu schreiben welcher bei der Kompilierung der Anwendung übernommen wird. 
Dadurch ist das mischen von Java und Javascript bei der Entwicklung möglich.

In unserem konkreten Problem haben wir eine neue Composite Klasse erstellt die Methoden zum setzen und lesen des Slider Wertes ermöglicht. Weiter ist es möglich ein SliderListener Interface zu setzen der beim "slide"-Event aufgerufen wird. Das Custom-Widget erstellt ein neues DIV Element, in welches mithilfe von jQuery UI ein Slider-Element eingebettet wird. Aus dem Javascript wird die Slide-Methode der Java Seite aufgerufen.
