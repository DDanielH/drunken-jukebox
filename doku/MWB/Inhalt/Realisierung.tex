\section{Realisierung}

In diesem Kapitel wird die konkrete Umsetzung der Anforderungen in GWT beschreiben.
Zuerst wird die Architektur der Anwendung festgelegt. Anschließend werden konkrete
Implentierungsdetails erläutert, welche die Erstellung eigener Widgets in GWT und
mittels JSNI, das Styling in GSS sowie die Lokalisierung umfassen.

\subsection{Architektur}

Um den Anforderungen der zwei Anwendergruppen (Veranstalter und Gäste einer Party) gerecht
zu werden, entwickeln wir zwei GWT-Anwendungen. Die Admin-Oberfläche wird als Desktop-Webanwendung
entwickelt, während die Vote-App als mobile Webanwendung umgesetzt wird. Trotzdem werden
beide Anwendungen mit einer ähnlichen Softwarearchitektur implementiert.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/Architektur-Ueberblick}
\caption{Überblick über die Architektur der beiden Anwendungen}
\label{fig:Architektur-Ueberblick}
\end{figure}

Die Frontend-Webapplikationen kommunizieren über GWT-RPC mit einem Java-Server. Dieser dient als 
Proxy zum deployd\footnote{\url{http://deployd.com/}}-Server und enthält selbst keine Applikationslogik. Auf diese Weise umgehen wir das Problem der Same-Origin-Policy. Der deployed-Server
ist für die Persistenz der Daten und die Anwendungslogik verantwortlich und wird über eine
HTTP-Schnittstelle angesprochen.

\subsubsection{Frontend}
Innerhalb der GWT-Frontend-Anwendungen wird das MVP-Pattern zur Trennung von Steuerung und Anzeige
der Oberfläche implementiert. Der Zugriff auf das Model wird über GWT-RPC-Services ermöglicht, die Anfragen an den Java-Server im Backend durchführen.

\begin{figure}[tbh]
\centering
\includegraphics[width=0.6\linewidth]{Bilder/MVP-mit-Service}
\caption{MVP-Pattern mit Service}
\label{fig:MVP-mit-Service}
\end{figure}

Im Folgenden werden die erstellten View-Presenter-Paare und deren Aufgaben kurz vorgestellt:
\begin{description}
	\item[PartyManagamentView und -Presenter:] Verwalten einer Party im Admin
	\item[SongManagementView und -Presenter:] Verwalten der Songsammlung im Admin
	\item[LanguageSelectionView und -Presenter:] Ändern der Anzeigesprache im Admin
	\item[VoteAppView und -Presenter:] Teilnahme an einer Party als Gast über die Vote-App
\end{description}

\subsubsection{Backend}
Das Backend besteht aus einem Java-Server, der als Proxy zur Umgehung der Same-Origin-Policy dient, und einem deployd-Server, der für die eigentliche Datenhaltung
und Anwendungslogik verantwortlich ist.

Der deployd-Server stellt Ressourcen über eine HTTP/REST-Schnittstelle bereit. Als
Datenformat wird JSON verwendet. Zur Einrichtung des deployd-Servers sind zwei Schritte
notwendig. Zunächst müssen die verwendeten Ressourcen definiert werden. Im zweiten
Schritt kann eigener Code\footnote{Der Code wird in JavaScript hinterlegt, da deployd auf node.js basiert.} hinterlegt werden, der beim Zugriff auf die Ressourcen
ausgeführt wird. Auf diese Weise konnten wir das notwendige Datenmodell und die
dazugehörige Anwendungslogik hinterlegen.

Die von uns definierten Ressourcen umfassen:
\begin{description}
	\item[/party] Daten über die aktuell laufende Party
	\item[/playlist] Die aktuelle Playlist (Songs und deren Votes)
	\item[/currentsong] Der Song, der gerade gespielt wird
	\item[/song] Songsammlung, aus der Songs für die Playlist gewählt werden
\end{description}

\subsection{Eigene Widgets}
Im Rahmen der Realisierung sind viele eigene Widgets entstanden. Um ein eigenes Widget zu implementieren leitet man von der Klasse Composite ab und ruft im Konstruktor die Methode initWidget auf. Neben kleineren Hilfskomponenten haben wir vor allem die Views als eigene Widgets realisiert.

Im Folgenden wird exemplarisch die Hilfskomponente InputBox und die SongListView vorgestellt.

\subsubsection{InputBox}
Die InputBox ist eine simple Hilfskomponente die eine TextBox und mit einem Label versieht:

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{Bilder/InputBox}
\caption{InputBox für den Interpreten eines Songs}
\label{fig:InputBox}
\end{figure}

Die Schnittstelle für die InputBox sieht wie folgt aus:
\begin{figure}[H]
\centering
\includegraphics[width=0.4\linewidth]{Bilder/InputBoxClass}
\caption{Schnittstellenbeschreibung der InputBox}
\label{fig:InputBoxClass}
\end{figure}




\subsubsection{SongListView}

 Zum Einen Neben kleineren 


- Kleinere Widget 
- Views als eigene Widgets implementiert

Bei der Implementierung der Views haben wir meist unsere eigenen Widgets erstellt


Bei der Implementierung der Views haben wir neben den in GWT bereits vorhandenen Widgets auch eigene Widgets erstellt, von denen wir im weiteren Verlauf einige vorstellen.

- Input Box
- Song Liste mit Suchbox
- Song Detailansicht
- 

- Search Dinge
- PlaylistEntries => CurrentSongWidget?

Beispiele

Chris

\subsection{Styles in GSS}
Für das Styling der beiden GWT-Anwendungen verwenden wir GSS. Da es unterschiedliche Anforderungen
an Deskop- und Mobilanwendungen gibt, werden zwei Stylesheet-Dateien verwendet.

- Verknüpfung: Client-Bundle und GSS-Dateien
- Gemeinsame Styles auslagern?

Fabian

\subsection{Lokalisierung}
Beide Anwendungen sollen lokalisiert in Deutsch und Englisch angeboten werden.
Im Admin soll es möglich sein die Sprache über die Oberfläche zu ändern, während
in der Vote-App die Sprache automatisch ausgewählt wird.

Dazu verwenden wir Ressourcen-Strings (TODO).

Fabian

\subsection{JSNI}
Slider mit jQuery

Daniel