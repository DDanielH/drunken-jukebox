\section{Technische Realisierung}
In diesem Kapitel gehen wir auf die technische Realisierung des Projektes ein. Im Abschnitt Domänenmodell werden zunächst die verwendeten Begriffe definiert. Anschließend wird auf die Architektur, das Datenmodell und die Authentifizierung der Benutzerrollen eingegangen. Abschließend beschreiben wir exemplarisch einen Methodenaufruf, mit dem die wichtigsten Komponenten des Systems vorgestellt werden.

\subsection{Domänenmodell}
\label{sec:Domaenenmodell}
Damit innerhalb des Projektes Bezeichnungen einheitlich verwendet werden, definieren wir im Folgenden alle relevanten Begriffe.

\subsubsection{Drunken-Jukebox}
Unter der Drunken-Jukebox verstehen wir eine datenbankgestützte WildFly-Anwendung, die folgende Aufgaben beinhaltet:

\begin{itemize}
	\item Verwaltung der Songs und Song-Informationen.
		\begin{itemize}
			\item Songs hinzufügen.
			\item Songs löschen.
			\item Song-Informationen bearbeiten.
		\end{itemize}
	\item Generierung und Verwaltung der Playlist.
\end{itemize}

\subsubsection{Roles}
Unter Roles verstehen wir die Benutzerrollen, die innerhalb der Drunken-Jukebox existieren:

\begin{description}
	\item [Admin] Verwaltet die Songs auf dem Server.
	\item [Player] Ist für das Abspielen von Songs verantwortlich.
	\item [Party-People] Gäste der Party, die eindeutig identifizierbar sind und Songs voten können.
\end{description}

\subsubsection{Party}
Eine Party besteht aus folgenden Daten: Start- und Enddatum, Playlist und Party-People. Darüber hinaus enthält die Party eine Liste von bereits gespielten Songs. Innerhalb der Drunken-Jukebox kann es maximal nur eine laufende Party geben.

\subsubsection{Song}
Ein Song innerhalb der Drunken-Jukebox enthält folgende Daten: Titel, Interpret, Genre, Album und Länge. Darüber hinaus enthält der Song eine \nameref{Song-Source}.

\subsubsection{Song-Source}
\label{SongSource}

Bei der Song-Source unterscheiden wir zwischen unterschiedlichen Quellen aus denen der Song abgespielt werden kann:
\begin{itemize}
	\item Pfad im Dateisystem
	\item Internet-Stream
	\item YouTube-Link
\end{itemize}

\subsubsection{Current-Song}
Der Current-Song ist der Song, der aktuell auf der Party abgespielt wird. Sobald der aktuelle Song beendet ist, wird der erste Song aus der Playlist entfernt und zum neuen Current-Song. 

\subsubsection{Playlist}
Die Playlist ist eine Liste von Songs, die basierend auf den Votings absteigend sortiert ist. Sie hat eine feste Größe und wird durch die Song-Selection generiert.

\subsubsection{Song-Selection}
Die Song-Selection ist für die Generierung der Playlist zuständig. Für die Auswahl der Songs haben wir einen eigenen Algorithmus entwickelt, der im Kapitel \nameref{sec:SongSelect} erklärt wird.

\subsubsection{Voting}
Über Votings können Party-People Songs innerhalb der Playlist bewerten. Dabei wird zwischen dem positiven Up-Vote und dem negativen Down-Vote unterschieden. Ein Party-People kann pro Song nur einmal voten.

Insgesamt berechnet sich der Vote wie folgt:\\
\textit{Vote v = Anzahl(Up-Votes) - Anzahl(Down-Votes)}

\subsubsection{DI}
Der DI ist ein ganzzahliger Wert zwischen 0 und 100 und beschreibt damit den Betrunkenheitsgrad eines Party-People.

\subsection{Architektur}

\todo{Daniel - Systemübersicht / Komponentendiagramm
	- Beans und deren Aufgaben}



\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{Bilder/Komponentendiagramm}
	\caption{Komponentendiagramm der Systemübersicht }
	\label{fig:Komponentendiagramm}
\end{figure}

Abbildung \ref{fig:Komponentendiagramm} ist eine Systemübersicht der Drunken-Jukebox. Es zeigt eine schematische Darstellung der vier Logikschichten. Diese Schichten sind horizontal im Komponentendiagramm dargestellt.

Die unterste Ebene mit dem Entity-Model beinhaltet die Persistenz-Logik. Mit Hilfe von Hibernate und einer beliebigen Datenbank werden die Daten verwaltet.
Über dieser Ebene befinden sich die Beans. Alle Beans benutzen das Entity-Model zur  Persistierung der Daten. Es gibt einen PlayerBean, einen PartyBean und einen AdminBean.

Der PlayerBean sendet die zu spielenden Songs an das Topic. 
Die Aufgaben des AdminBean ist das Starten einer Party, die damit verbundene Initialisierung der Playlist und die Auswahl der zu spielenden Songs. Beim Initialisieren der Playlist wird diese mithilfe eines Song-Selection-Algorithmus gefüllt. Die Anzahl der Einträge in der Playlist ist im AdminBean definiert. Weiter gehört zum Starten einer Party die Auswahl eines zu spielenden Songs. Beim Auswählen wird anhand der Song-Source  ein Timer eingestellt, der nach der Länge (in Sekunden) des Songs ausgelöst wird. Dieser Timer persistiert den gespielten Song für spätere Auswertungen und wählt den nächsten Song aus der Playlist aus. Bei jedem Auswählen eines zu spielenden Songs wird dieser aus der Playlist entfernt und über den Song-Selection-Algorithmus ersetzt.

Das PartyBean verwaltet die Votes und die DI-Werte der Party-People. Votes werden mit einem Song, einem Up-or-Down-Ranking und der ID des Party-People persistiert. DI-Werte werden mit der Party-People-ID persistiert.

Über den Beans befindet sich die Topic und die REST API. Eine Topic ist eine eigenständige Liste in der das PlayerBean Songs eintragen kann. Ein Player-Client kann sich an dem Topic registrieren. Bei jedem neuen Eintrag erhält jeder registrierte Client diesen Eintrag. 

Die REST-API injected die Beans für das Durchreichen der Anfragen. Diese Drei Schichten befinden sich im Application-Server WildFly.

Die letzte Schicht enthält die verschiedenen Clients. Der Player-Client bekommt von dem Topic die Song-Source und spielt diese ab. Ein Party-Client kann Votes und DI-Werte an den Server senden. Der Admin-Client kann Songs und Benutzer verwalten. In diesem Projekt wurde nur der Server und die Schnittstellen für die Clients entwickelt.

\subsection{Datenmodell}

In diesem Abschnitt wird das Datenmodell beschrieben. Dieses besteht aus Entitäten für die Objekte aus dem \nameref{sec:Domaenenmodell}, die persistiert werden sollen. Benutzer- und Rollendaten werden im Abschnitt \ref{sec:Benutzerrollen} beschrieben.

\begin{figure}[htb]
\centering
\includegraphics[width=1\linewidth]{Bilder/Datenmodell}
\caption{Datenmodell mit Beziehungen und Cascading zwischen Entitäten}
\label{fig:Datenmodell}
\end{figure}

Abbildung \ref{fig:Datenmodell} zeigt die Entitäten sowie deren Beziehungen untereinander. Neben der Kardinalität ist in dem Diagramm auch das Cascading-Verhalten dokumentiert. Wir haben zwei unterschiedliche Arten verwendet:
\begin{description}
	\item[Refresh] Eine Entität kennt eine andere Entität. Änderungen oder Löschoperationen werden nicht an die verknüpfte Entität weitergeleitet (Abhängigkeit).
	\item[All] Eine Entität besitzt eine andere Entität. 
	Änderungen oder Löschoperationen werden an die 
	verknüpfte Entität weitergeleitet (Aggregation).
\end{description}

Eine Anforderung an das Projekt ist es, möglichst alle Beziehungs- und Kardinalitätstypen sinnvoll anzuwenden. Aus diesem Grund werden im Folgenden relevante Beziehungen zwischen Entitäten und deren Kardinalitäten erläutert.

\begin{description}
	\item[One-To-One, Refresh] Eine Party kennt einen aktuellen Song. Da es immer nur eine laufende Party geben kann, ist ein Song auch maximal einer Party als aktueller Song zugeordnet. Der Cascading-Typ ist Refresh, weil beim Beenden einer Party der Song natürlich weiterhin in der Datenbank erhalten bleiben soll.
	\item[One-To-One, All] Ein Song hat eine SongSource. Eine SongSource enthält die Informationen zum Abspielen des Songs. Wird der Song geändert oder gelöscht, so soll sich dies direkt auf die SongSource auswirken.
	\item[Many-To-One, Refresh] Ein Vote kennt den Song, auf den sich die Bewertung bezieht. Ein Song kann von mehreren Votes bewertet worden sein. Änderungen oder Löschen eines Votes soll keinen Einfluss auf die betroffenen Song-Daten haben.
	\item[One-To-Many, All] Eine Playlist besteht aus einer Liste von PlaylistEntry-Entitäten. Ein PlaylistEntry ist genau einer Playlist zugeordnet. Werden Änderungen an der Playlist vorgenommen, so sollen diese auch an die Einträge
	in der Liste weitergeleitet werden.
	\item[Many-To-Many, Refresh] Ein Song kann mehreren Genres zugeordnet werden. Zu einem einem Genre gehören beliebig viele Songs. Beim Löschen oder Ändern eines Songs soll das entsprechende Genre weiterhin bestehen bleiben und umgekehrt.
	\item[Inheritance] Eine SongSource kann mehrere Ausprägungen haben. Eine LocalFileSource identifiziert eine lokale Datei, während eine YouTubeSource eine Video auf YouTube identifiziert.
\end{description}



\subsection{Benutzerrollen}
\label{sec:Benutzerrollen}
Die Authentifizierung und Autorisierung von Benutzer erfolgt über das Sicherheitskonzept im WildFly. Dazu werden Benutzerrollen für die unterschiedlichen Anwender definiert. Der Zugriff auf Beans sowie die REST-Services wird über diese Rollen geregelt. 

\subsubsection{Konzept}
Es gibt drei Benutzerrollen: Admin, Player und PartyPeople.
\begin{description}
	\item[Admin] Ein Administrator hat Zugriff auf das Admin-Bean und den Admin-Service, um Songs und Partys zu verwalten.
	\item[Player] Ein Player hat Zugriff auf das DJ-Topic, um Nachrichten zum Abspielen von Songs zu empfangen.
	\item[PartyPeople] PartyPeople haben als Gäste der Party Zugriff auf das Party-Bean und den Party-Service.
\end{description}

\subsubsection{Umsetzung}
Die Benutzer- und Rollendaten werden in der Datenbank gespeichert. Dazu wurden die zwei Entitäten \texttt{Principal} und \texttt{Role} angelegt. In der Datenbank wird zur Zuordnung zwischen Benutzern und Rollen eine zusätzliche Verknüpfungstabelle angelegt. Die Tabellen werden in Abbildung \ref{fig:BenutzerRollen} dargestellt.

\begin{figure}[tbh]
\centering
\includegraphics[width=1.0\linewidth]{Bilder/BenutzerRollen}
\caption{Tabellen für die Benutzerverwaltung}
\label{fig:BenutzerRollen}
\end{figure}

Im Standard verwendet WildFly die lokalen Benutzerdaten in den *.properties-Dateien. Um das Verhalten zu ändern, muss ein neues Login-Modul in der standalone.xml angelegt werden. In dieses Datenbank-Login-Modul die Datenquelle zusammen mit den SQL-Abfragen zur Bestimmung von Passwörtern und Rollen definiert werden. Aktuell werden die Passwörter im Klartext gespeichert. Für den produktiven Einsatz sollte hier auf ein aktuelles Hash-Verfahren wie SHA-2 umgestellt werden.

Um denselben Authentifizierungsmechanismus für Remote-Verbindungen und HTTP-Anfragen gegen den REST-Service zu nutzen, haben wie eine eigene Security-Realm sowie -Domain definiert. Zusätzlich war die Einstellung für Passwort-Stacking wichtig, da sonst entweder nur die Anmeldung über die REST-Schnittstelle oder über Remote möglich war. Die Zuordnung der Security-Domain zu den Beans und Services erfolgt über Annotationen an den entsprechenden Java-Klassen. 

\subsubsection{Probleme}
Die Authentifizierung war das größte Problem im gesamten Projekt, das entsprechend auch mit dem höchsten Arbeitsaufwand verbunden. Selbst nach stundenlanger Recherche konnten einige Probleme aufgrund der eher mangelhaften Dokumentation und der wenig hilfreichen Fehlermeldungen nicht oder nur teilweise gelöst werden.

Besonders auffällig war, dass die einzelnen Features wie Remote-Authentifizierung einfach einzurichten waren. Sollte dieselbe Authentifizierung auch für REST-Service genutzt werden, mussten aufwendige und nicht dokumentierte Anpassungen an der WildFly-Konfiguration vorgenommen werden. Als gegen Ende des Projekts auch das Messaging authentifiziert werden sollte, konnten wir keine Lösung finden, mit der alle drei Schnittstellen korrekt arbeiteten. Aktuell funktioniert die Authentifizierung für Remote- und HTTP-Verbindungen. 


\subsection{Exemplarische Darstellung}
Dieser Abschnitt beschreibt exemplarisch einen Funktionsaufruf der REST-API. Da die verschiedenen über REST bereitgestellten Funktionen prinzipiell gleich implementiert sind, zeigt Abbildung \ref{fig:AufrufSequenz} den Ablauf der Funktion "`Party starten"'.

\begin{figure}[tbh]
\centering
\includegraphics[width=1.0\linewidth]{Bilder/AufrufSequenz}
\caption{Sequenzdiagramm für den Start einer Party}
\label{fig:AufrufSequenz}
\end{figure}

Um eine Party zu starten führt der Admin-Client einen HTTP-POST-Request unter der URI /admin/party aus. Daraufhin wird im Admin-Service die startParty-Methode des Admin-Beans aufgerufen. Die Abhängigkeiten der Service- und der Bean-Klasse werden dabei über Dependency-Injection aufgelöst. Innerhalb des Admin-Beans wird eine neue Instanz der Entität Party erstellt und in der Datenbank persistiert. Abschließend gibt der Admin-Service den HTTP-Status-Code 200 zurück.

\subsection{Song-Selection-Algorithmus}
\label{sec:SongSelect}
Die Playlist wird über einen Algorithmus zur Auswahl von passenden Songs gefüllt. Dazu werden bekannte Kriterien über die aktuelle Party wie Uhrzeit und durchschnittlicher Betrunkenheitsgrad berücksichtigt. Die Auswahl erfolgt auf Basis von bereits abgeschlossenen Partys, bei denen zu den gespielten Songs die notwendigen Daten gespeichert wurden.

